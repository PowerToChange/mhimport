c({"name": "Server.prototype.use", "params": {"route": {"description": "<p>or handle</p>", "type": "String|Function", "optional": false, "order": 0, "name": "route"}, "handle": {"description": "", "type": "Function", "optional": false, "order": 1, "name": "handle"}}, "ret": {"description": "", "type": "Server"}, "type": "function", "comment": "<p>Utilize the given middleware <code>handle</code> to the given <code>route</code>,\ndefaulting to <em>/</em>. This \"route\" is the mount-point for the\nmiddleware, when given a value other than <em>/</em> the middleware\nis only effective when that segment is present in the request's\npathname.</p>\n\n<p>For example if we were to mount a function at <em>/admin</em>, it would\nbe invoked on <em>/admin</em>, and <em>/admin/settings</em>, however it would\nnot be invoked for <em>/</em>, or <em>/posts</em>.</p>\n\n<p>This is effectively the same as passing middleware to <code>connect.createServer()</code>,\nhowever provides a progressive api.</p>\n\n<p>Examples:</p>\n\n<pre><code> var server = connect.createServer();\n server.use(connect.favicon());\n server.use(connect.logger());\n server.use(connect.static(__dirname + '/public'));\n</code></pre>\n\n<p>If we wanted to prefix static files with <em>/public</em>, we could\n\"mount\" the <code>static()</code> middleware:</p>\n\n<pre><code> server.use('/public', connect.static(__dirname + '/public'));\n</code></pre>\n\n<p>This api is chainable, meaning the following is valid:</p>\n\n<pre><code> connect.createServer()\n   .use(connect.favicon())\n   .use(connect.logger())\n   .use(connect.static(__dirname + '/public'))\n   .listen(3000);\n</code></pre>\n\n<p>@api public</p>", "src": "appDev/node_modules/express/node_modules/connect/lib/http.js", "line": 50, "children": []})