////
//// dataManager
////
//// A generic object for receiving client data object CRUD operations.
////
//// This object maintains the data structure for a given data unit
//// (db table) and any necessary connectivity info for it's DataStore 
//// object.
//// 
//// 

var log = AD.Util.Log;
var $ = AD.jQuery;

var DataStore = AD.Model.Datastore;

var ModelInstance = require('model_Instance.js');


var DataManager = function (properties) {

  this.dbTable='';
  this.model = {};
  this.primaryKey = '';

  for (var key in properties) {
    this[key] = properties[key];
  }
};

module.exports = DataManager;





DataManager.prototype._new = function( attr ) {
    
    // does this work?
    if (typeof attr == 'undefined') return null;
   
    return new ModelInstance(attr, this);
    
}

DataManager.prototype._model = function( attr ) {
    
    // does this work?
    if (typeof attr == 'undefined') return null;
    
    var obj = this._new(attr);
    
    return obj;
    
}


DataManager.prototype._notificationKey = function() {
    // return the this.__hub.publish(key, data)  key for this model object.
    // all Model objects will define a default key as [Module].[Model]
    // each CRUD operation then appends a verb to the end: [Module].[Model].verb
    return this.__adModule + '.' + this.__adModel;
}



// Return an object representing the model of the Table we are managing:
//   key:value pairs of all table entries.
//
DataManager.prototype.getModel = function( ) {
    return this.model;
}



//Return an object representing the current request for this table
//key:value pairs of all table entries.
//
DataManager.prototype.getCurrentDataMgr = function(currModel, otherParams) {
    var curDataMgr = {
            dbName:this.dbName || AD.Defaults.dbName,
            dbTable:this.dbTable,
            model: currModel
            };
    if (typeof otherParams != 'undefined') {
        for (var param in otherParams) {
            curDataMgr[param] = otherParams[param];
        }
    }
    return curDataMgr;
}



// Evaluates whether or not the given keyName is the primary key for this table.
//
DataManager.prototype.isAPrimaryKey = function( name ) {
    return (this.primaryKey == name);
}


DataManager.prototype.condFromReq = function( req ) {

    var cond = '';

    // get a reference to the data from the submission:
    var providedData = {};
    if (typeof req.body != 'undefined') {
        providedData = req.body;
    } else if (typeof req.query != 'undefined') {
        providedData = req.query;
    } else {
        log(req, 'dataManager.condFromReq() :: no req.body / req.query found. ==> passing.');
    }
    
    
    if (typeof providedData.dbCond != 'undefined') {
        cond = providedData.dbCond;
    }
    
    return cond;
}



DataManager.prototype.loadFromReq = function( req, allowFilters ) {

    
    var curModel = {};

    if (req == null)  return curModel;

    var providedData = {};
    if (typeof req.body != 'undefined') {
        providedData = req.body;
    } else if (typeof req.query != 'undefined') {
        providedData = req.query;
    } else {
        log(req, 'dataManager.loadFromReq() :: no req.body / req.query found. ==> passing.');
    }
    
    
    // search each body value for Model info and store them:
    for (var key in providedData) {
    
        //if modelKey is in this.model then store it:
        if (   (typeof this.model[key] != 'undefined')
            || (key == 'language_code')
            || (allowFilters && this.filters && (typeof this.filters[key] != 'undefined')) ) {

            // store the value
            curModel[key] = providedData[key];
        }
    }
    
    return curModel;
}



DataManager.prototype.langFromReq = function( req ) {

    
    var curModel = {};

    if (req == null)  return curModel;

    var providedData = {};
    if (typeof req.body != 'undefined') {
        providedData = req.body;
    } else if (typeof req.query != 'undefined') {
        providedData = req.query;
    } else {
        log(req, 'dataManager.langFromReq() :: no req.body / req.query found. ==> passing.');
    }
    
    
    // search for language
    var key = 'language_code';
    if (typeof providedData[key] != 'undefined') {
        // store the value
        curModel[key] = providedData[key];
    }
    
    return curModel;
}


////----------------------------------------------------------------------
DataManager.prototype.create = function (attr, onSuccess, onError ) {
    ////  mimic the create() behavior just like the Client Side code.
    ////
    
    var dfd = $.Deferred();
    this.createFromReq({
        id:-1,
        req:{
            query:attr
        },
        callback:function(err, data) {
            if (err) { 
                if (typeof onError != 'undefined')  onError( err ); 
                dfd.reject(err);
            }
            else {
                // must return { id: new ID value }
                if (typeof onSuccess != 'undefined') onSuccess(data);
                dfd.resolve(data);
            }
        }
    });
    return dfd;
}




DataManager.prototype.createFromReq = function (params) {

    var req = params.req;
    var callback = params.callback;


    // create a temporary obj for this transaction:
    var currModel = this.loadFromReq(req);
    

    var curDataMgr = this.getCurrentDataMgr(currModel);

    // if this.isDataValid() 
    
    var primaryKey = this.primaryKey;
    
    var returnObj = { };
    returnObj[primaryKey] = '-1';
    
    var _self = this;
    return DataStore.create( curDataMgr, function( err, data) {   
    
        // if we have a notification hub defined:
        if (_self.__hub != null) {
            
            // Publish a .created notification for this Model:
            // published data:  { id: [newPrimaryKeyValue] }
            var subscriptionKey = _self._notificationKey() + '.created';
            _self.__hub.publish(subscriptionKey, {id:data});
        } 
        
        
        
        // the mysql obj returns the insertID of the new row.
        // here we package it in an obj that reflects this object's 
        // primaryKey field
        returnObj[primaryKey] = data;
        
        callback(err, returnObj);
        
    });  // returns True|False
}







////----------------------------------------------------------------------
DataManager.prototype.update = function (id, attr, onSuccess, onError ) {
    ////  mimic the create() behavior just like the Client Side code.
    ////
    
    var dfd = $.Deferred();
    this.updateFromReq({
        id:id,
        req:{
            query:attr
        },
        callback:function(err, data) {
            if (err) { 
                if (typeof onError != 'undefined') onError( err ); 
                dfd.reject(err);
            } else {
                // must return { id: new ID value }
                if (typeof onSuccess != 'undefined') onSuccess(data);
                dfd.resolve(data);
            }
        }
    });
    return dfd;
}



DataManager.prototype.updateFromReq = function (params) {

if (typeof params.req == 'undefined') {
console.log('invalid parameters provided:');
console.log(params);
}
    var req = params.req;
    var id = params.id;
    var callback = params.callback;
    

    // create a temporary obj for this transaction:
    var currModel = this.loadFromReq(req);
    
    var condition = this.condFromReq(req);

    var otherParams= {
            primaryKey:this.primaryKey,
            id:id,
            cond:condition
            };
    var curDataMgr = this.getCurrentDataMgr(currModel, otherParams);
        
// if this.isDataValid() 

    var returnObj = { };
    
    var _self = this;
    
    DataStore.update( curDataMgr, function( err, data) {   
    
        // if we have a notification hub defined:
        if (_self.__hub != null) {
            
            // Publish an .updated notification for this Model:
            // published data:  { id: [newPrimaryKeyValue] }
            var subscriptionKey = _self._notificationKey() + '.updated';
            _self.__hub.publish(subscriptionKey, {id:id});
        }

        
        callback(err, returnObj);
        
    });  
}




////----------------------------------------------------------------------
DataManager.prototype.destroy = function (id, onSuccess, onError ) {
    ////  mimic the create() behavior just like the Client Side code.
    ////
    
    var dfd = $.Deferred();
    this.destroyFromReq({
        id:id,
        req:{
            query:{}
        },
        callback:function(err, data) {
            if (err) { 
                if (typeof onError != 'undefined') onError( err ); 
                dfd.reject(err);
            }else {
                // must return { id: new ID value }
                if (typeof onSuccess != 'undefined') onSuccess(data);
                dfd.resolve(data);
            }
        }
    });
    return dfd;
}



DataManager.prototype.destroyFromReq = function (params) {

    var req = params.req;
    var id = params.id;
    var callback = params.callback;

    // create a temporary obj for this transaction:
    var currModel = {};
    currModel[this.primaryKey] = id;
    

    var curDataMgr = this.getCurrentDataMgr(currModel);
        
// if this.isDataValid() 

    var returnObj = { };
    var _self = this;
    
    DataStore.destroy( curDataMgr, function( err, data) {   
    

        // if we have a notification hub defined:
        if (_self.__hub != null) {
            
            // Publish a .destroyed notification for this Model:
            // published data:  { id: [newPrimaryKeyValue] }
            var subscriptionKey = _self._notificationKey() + '.destroyed';
            _self.__hub.publish(subscriptionKey, {id:id});
        }
        
        callback(err, returnObj);
        
    });  
}




////----------------------------------------------------------------------
DataManager.prototype.findOne = function (attr, onSuccess, onError ) {
////  mimic the create() behavior just like the Client Side code.
////
    var query = {};
    var id = -1;
    if (typeof attr.id != 'undefined') id = attr.id;
    if (typeof attr[this.primaryKey] != 'undefined') id = attr[this.primaryKey];

    // Add in language code to query
    var key = 'language_code';
    if (typeof attr[key] != 'undefined') query[key] = attr[key];

    var _self = this;
    var dfd = $.Deferred();
    this.findoneFromReq({
        id:id,
        req:{
            query:query
        },
        callback:function(err, data) {
            if (err) { 
                if (typeof onError != 'undefined') onError( err ); 
                dfd.reject(err);
            }else {
                // must return { id: new ID value }
                
                // we are returned an array of objects
                // need to take the first and turn it into an Instance:
                var instance = null;
                if (typeof data[0] != 'undefined') {
                    instance = _self._new(data[0]);
                }
                
                if (typeof onSuccess != 'undefined') onSuccess(instance);
                dfd.resolve(instance);
            }
        }
    });
    return dfd;
}




// read a single entry from the DB (by ID)
DataManager.prototype.findoneFromReq = function (params) {

    var req = params.req;
    var id = params.id;
    var callback = params.callback;

    // create a temporary obj for this transaction:
    var currModel = this.langFromReq(req);
    currModel[this.primaryKey] = id;  // setup the pk=>id key=>value pair
    

    var curDataMgr = this.getCurrentDataMgr(currModel, {joinedTables: []});

    this.read(req, curDataMgr, callback);
}




////----------------------------------------------------------------------
DataManager.prototype.findAll = function (attr, onSuccess, onError ) {
////mimic the create() behavior just like the Client Side code.
////
    var _self = this;
    
    var dfd = $.Deferred();
    this.findallFromReq({
        id:-1,
        req:{
            query:attr
        },
        callback:function(err, data) {
            if (err) { 
                if (typeof onError != 'undefined') onError( err ); 
                dfd.reject(err);
            }else {
                
                // we are returned an array of objects
                // need to turn these into an array of Instances:
                var listInstances =  [];
                for(var i=0; i<data.length; i++) {
                    listInstances.push( _self._new(data[i]));
                }

                if (typeof onSuccess != 'undefined') onSuccess(listInstances);
                dfd.resolve(listInstances);
            }
        }
    });
    return dfd;
}

// read multiple entries (can be conditioned by passed in parameters)
DataManager.prototype.findallFromReq = function (params) {

    var req = params.req;
    var callback = params.callback;
    
    
    // create a temporary obj for this transaction:
    var currModel = this.loadFromReq(req, true);

    var condition = this.condFromReq(req);

    // Take care of extra filter keys, if provided
    var joinedTables = this.getFilterJoins(currModel);

    var otherParams= {
            cond:condition,
            joinedTables: joinedTables
            };
    var curDataMgr = this.getCurrentDataMgr(currModel, otherParams);
    
    this.read(req, curDataMgr, callback);
}


DataManager.prototype.read = function (req, curDataMgr, callback) {

    // First, do final preparation of the Data Manager.
    curDataMgr.selectedFields = { _empty: true };
    this.addLookupLabels(req, curDataMgr);
    this.prepForRead(req, curDataMgr);
    var selectedFields = (curDataMgr.selectedFields._empty) ? this.model : curDataMgr.selectedFields;
    
    // Now, execute the read
    DataStore.read( curDataMgr, function(err, results, fields) { 
    
        // now return an object with all our key=>values set:
        var returnArray = [];
        
        var returnObj = {};
        
        if (err) {
        
            console.log(err);
        
        } else {
        
            if (results.length < 1) {
            
                log(req,' returned results < 1  length['+results.length+']');
                
                //hope this doesn't break anything but how come we are returning an array with 1 empty object?
                //array length with be zero now if no results
                //returnArray.push(returnObj);
            
            } else {
            
                for (var ri=0; ri < results.length; ri++) {

                    returnObj = {};
                    
                    for (var key in selectedFields) {
                    
                        if (typeof results[ri][key] != 'undefined') {
                        
                            returnObj[key] = results[ri][key];
                            
                        } else {
                        
                            log(req,' *** key['+key+'] not part of resultSet');
                        }
                        
                    }
                    
                    returnArray.push(returnObj);
                
                }
            }
            
        }
//        log(req, 'returnedData :');
//        log(req, returnArray);

if (typeof callback == 'undefined') {
    LogDump(req, 'here is an error.');
    throw ('someone didnt include a req in the params to this fn()');
}

        callback(err, returnArray);
        
    });  // returns True|False

}


DataManager.prototype.getFilterJoins = function (currModel) {
    var joinedTables = [];
    if (this.filters) {
        for (var key in this.filters) {
            var filterTref = 1;
            if (typeof currModel[key] != 'undefined') {
                // This key really belongs to another table; prepare the JOIN
                var value = currModel[key];
                
                var keyArray = [];
                
                var joinKey = key;
                var failure = false;
                do {
                    keyArray.push(joinKey);
                    // problems!!!
                    if (typeof this.filters[joinKey] == 'undefined') {
                        failure = true;
                        break;
                    }
                    joinKey = this.filters[joinKey].foreignKey;
                } while (typeof this.model[joinKey] == 'undefined');
                
                var tref = ''
                var joinToTref = 'p';
                while (!failure && (keyArray.length > 0)) {
                    joinKey = keyArray.pop();
                    var joinedTable = copyTableInfo(this.filters[joinKey]);
                    tref = "f" + filterTref++;
                    joinedTable.tref = tref;
                    joinedTable.type = 'INNER';
                    joinedTable.joinToTref = joinToTref;
                    joinedTables.push(joinedTable);
                    joinToTref = joinedTable.tref;
                }

                if (!failure) {
                    // Remark the field in the current model (with tref)
                    currModel[key] = { tref: tref, value: value };
                }
            }
        }
    }
    return joinedTables;
}

var copyTableInfo = function(tableInfo) {
    var copiedInfo = {};
    copiedInfo.tableName = tableInfo.tableName;
    copiedInfo.foreignKey = tableInfo.foreignKey;
    if (typeof tableInfo.referencedKey != 'undefined') {
        copiedInfo.referencedKey = tableInfo.referencedKey;
    }
    if (typeof tableInfo.label != 'undefined') {
        copiedInfo.label = tableInfo.label;
    }
    return copiedInfo;
}



DataManager.prototype.addLookupLabels = function (req, curDataMgr) {
    // Determine which fields need to be selected
    var tref;
    // Add any lookup labels to the selected fields
    if (typeof this.lookupLabels != 'undefined') {
        var lookupTref = 1;
        var langCode = curDataMgr.model['language_code'] || req.aRAD.viewer.languageKey;

        for (var key in this.lookupLabels) {
            // This key really belongs to another table; prepare the JOIN
            tref = "t" + lookupTref++;

            var joinedTable = copyTableInfo(this.lookupLabels[key]);
            joinedTable.tref = tref;
            joinedTable.type = 'LEFT';
            joinedTable.joinToTref = 'p';
            // Add the field's language code to the current model (with tref)
            joinedTable.condition = [{ tref: tref, key: 'language_code', value: langCode }];
            curDataMgr.selectedFields[joinedTable.label] = { tref: tref };
            curDataMgr.joinedTables.push(joinedTable);
            
        }
        curDataMgr.selectedFields._empty = false;
    }
}

DataManager.prototype.prepForRead = function (req, curDataMgr) {
    // Get rid of the language code field, if it exists
    delete curDataMgr.model['language_code'];
    
    // Add all server model fields if there are any JOINs to prevent duplicate fields in response
    if (curDataMgr.joinedTables.length > 0) {
        for (var key in this.model) {
            // Set the tref for the primary table
            tref = "p";
            curDataMgr.selectedFields[key] = { tref: tref };
            
            if (typeof curDataMgr.model[key] != 'undefined') {
                // Remark the field in the current model (with tref)
                var value = curDataMgr.model[key];
                curDataMgr.model[key] = { tref: tref, value: value };
            }
        }
        curDataMgr.selectedFields._empty = false;
    }
}



