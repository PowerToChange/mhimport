////
//// Interface
////
//// An object that provides utility functions for Interface objects to 
//// perform their common tasks.
//// 
//// 

var log = AD.Util.Log;
var error = AD.Util.Error;
var relativePathFromRoot = AD.App.Page.relativePathFromRoot;
var relativePath = AD.App.Page.relativePath;

var $ = AD.jQuery;

/**
 * @class AD.App.Interface
 * @parent AD_Server
 * 
 * A class that provides utility functions for Interface objects to perform 
 * their common tasks. The main exported object in every "node_[xxxx].js" 
 * interface source file should instantiate from this class.
 *
 * Use the provided `this.app` object when initializing routes, and not the 
 * global `app` object. See the `app.get()` function documentation for more 
 * information.
 *
 * Similarly, all .js files that are loaded in the interface are tracked.
 * Use `this.module.require()` instead of the global `require()` to allow 
 * proper tracking.
 */

function Interface( opt ) {

    this.version        = 1;    // v1 of our Interface definition
    this.hub            = null; // placeholder for Module's Notification Hub
    
    
    this.pathInterface  = '';
    this.nameInterface  = '';
    
    this.containers     = {};
    this.pathModules    = '';
    
    
    this.pathServices   = '';
    this.services       = {};
    
    this.pathLabels     = '';
    
    this.pathScripts    = '';
    this.myListJS       = [];
    this.myListJSLoaded = false;
    
    this.pathCSS		= '';	// path to interface css directory
    this.myListLocalCSS = [];	// array of paths to currently installed css files
    
    this.myListCSS       = [];	  // list of all CSS files required by this Interface (including sub Containers)
    this.myListCSSLoaded = false; // bool: has list been loaded?
    
    this.listWidgets     = [];  // list of widgets used at interface level
    
    this.listLabels      = [];
    this.listLabelsLoaded = false;
    
    for(var i in opt) {
        this[i] = opt[i];
    }
   
    var parts = this.pathInterface.split('/');
    
    this.nameInterface = parts[parts.length -1];
    
    this.listRoutes = {};
    this.app = new FakeApp(this); // mimics the Express `app` object
    
    
};
//util.inherits(Client, EventEmitter);
module.exports = Interface;









/**
 * @function app.get
 * Allows a module to register a route with the appDev framework. Works with
 * all common HTTP verbs, just use the verb name in place of `get`.
 *
 * Usage: 
 * @codestart
 * this.app.get('/page/foo/bar', function(req, res, next) { ... });
 * this.app.post('/service/foo/:bar', function(req, res, next) { ... });
 * this.app.put('/service/a/b/c', [fn, fn, fn], function(req, res, next) { ... });
 * @codeend
 *
 * Basically just add `this.` in front of your normal global `app` call,
 * when you are within the scope of an `Interface` object.
 */

var FakeApp = function(context) {
    this.context = context;
};

var routeVerbs = require('express/lib/router/methods.js').concat(['all']);
//['all', 'get', 'post', 'put', 'delete', 'head', ...];
for (var i=0; i<routeVerbs.length; i++) {
    // Create a closure so `verb` remains the same when the function evaluates
    (function(verb) {
        FakeApp.prototype[verb] = function(routePath, routeFn) {
            var self = this.context;
            if (!self.listRoutes[verb]) {
                self.listRoutes[verb] = {};
            }
            if (arguments.length == 2) {
                // basic route callback was given.
                self.listRoutes[verb][routePath] = routeFn;
            } else {
                // Multple callback arguments were given. Convert the 
                // arguments list into an array.
                var params = Array.prototype.slice.call(arguments);
                params.shift();
                self.listRoutes[verb][routePath] = params;
            }
        }
    })(routeVerbs[i]);
}



/**
 * @function getCSS
 *
 * Return the list of our CSS source files that need to be loaded by the 
 * client.
 *
 * This method is usually called from the interface's page load route and
 * incorporated back into the initial page build.
 *
 * @param {Array} list
 * @return {Array}
 */
Interface.prototype.getCSS = function( list ) 
{
    if (typeof list == 'undefined') {list = []};
    
    if (!this.myListCSSLoaded) { 
    
        this.loadCSS();
    
    } 
    
    for (var iL in this.myListCSS) {
        list.push(this.myListCSS[iL]);
    }
    
    return list;
}




/**
 * @function getJavascripts
 *
 * Return the list of our javascripts that need to be loaded by the client.
 *
 * This method is usually called from the steal() dependency
 * route: `/init/module/interface/interface.js`
 *
 * @param {Array} list
 * @return {Array}
 */
Interface.prototype.getJavascripts = function( list ) 
{

    if (typeof list == 'undefined') {list = []};
    
    if (!this.myListJSLoaded) { 
    
        this.loadJavascripts();
       
    } 
    
    
    for (var iL in this.myListJS) {
        list.push(this.myListJS[iL]);
    }
    
    return list;
}




//------------------------------------------------------------------------
/**
 * @function getLabels
 *
 * Return the labels associated with this interface.
 * These labels are used by the client side Multilingual object to display
 * information in various languages.
 *
 * This method is usually called from the steal() dependency
 * route: `/labels/module/interface/labels.js`
 *
 * @return {Array?}
 */
Interface.prototype.getLabels = function() 
{
    if (!this.listLabelsLoaded) { 
    
        this.loadLabels();
       
    } 
    
    return this.listLabels;
}




/**
 * @function loadContainers
 * 
 * Scans the defined `pathModules` directory to see if there are any sub 
 * containers for this interface to load.
 *
 * Sub containers can define their own javascripts, routes, and actions.
 *
 * @param {Function} onError
 * @return {Deferred}
 *    A jQuery Deferred that will be resolved after all containers have been
 *    loaded.
 */
Interface.prototype.loadContainers = function( onError ) 
{
    // set default path to interface directory if not already set:
    if (this.pathModules == '') {
        this.pathModules = this.pathInterface + '/containers';
    }
    
    var self = this;
    var dfd = $.Deferred();
    
    fs.readdir(this.pathModules, function (err, files) {


        if (err) { 
        
            if (typeof onError != 'undefined') {
                onError(err); 
            } else {
                error(' ');
                error('**** path['+relativePathFromRoot(self.pathModules)+']');
                error('**** error['+err.message+']');
            }
            
        } else {
        
            log(' ');
            log('      ... Loading Containers ['+relativePathFromRoot(self.pathModules)+']');
            for(var fi in files) {
                
                var modulePath = self.pathModules + '/'+files[fi]+'/node_'+files[fi]+'.js';
                
                if (path.existsSync(modulePath)) {
                
                    log('          - ['+relativePathFromRoot(modulePath)+']');
                    self.containers[files[fi]] = self.module.require('./containers/'+files[fi]+'/node_'+files[fi]+'.js');
                    
                }
                    
            }
            
            
            this.myListJSLoaded = false;

        }
        
        // Finished the async operation
        dfd.resolve({});
        
    });
    
    return dfd;
}





/**
 * @function loadCSS
 *
 * Compile a list of all the .css files that need to be loaded by the client.
 * The resulting list will be stored internally within the Interface object.
 *
 * All our sub containers are called to return their CSS lists as well.
 *
 * @param {String} scriptPath
 */
Interface.prototype.loadCSS = function( scriptPath ) 
{

	// for each .css in our list
    for (var wi =0; wi < this.myListLocalCSS.length; wi++) {
    
        this.myListCSS.push( this.myListLocalCSS[wi]);
       
    } // next css
	
	
    
    // for each widget in our dependency list
    for (var wi =0; wi < this.listWidgets.length; wi++) {
    
        var widgetKey = this.listWidgets[wi];
        
        // ListWidgets is a global defined by root app.js
        if (typeof ListWidgets[widgetKey] != 'undefined') {
        
            var widgetsListCSS = ListWidgets[widgetKey].listCSS;
            
            // for each css listed in widget list
            for (var ci =0; ci < widgetsListCSS.length; ci++) {
            
                // add to my currListCSS
                this.myListCSS.push( widgetsListCSS[ci] );
                
            } // next css
        }
//else {
//error('!!!Couldnt find widget['+widgetKey+'] in ListWidgets:');
//console.log(ListWidgets);

//}
    } // next widget
    
    
    
    // get all our container's css dependencies as well:
    for(var i in this.containers) {
    
        var curList = this.containers[i].getCSS(list);
        for (var iCL in curList) {
            this.myListCSS.push(curList[iCL]);
        }
        
    }
    
    this.myListCSSLoaded = true;
}




/**
 * @function loadJavascripts
 *
 * Compile a list of all the javascripts that need to be loaded by the client.
 * (Usually during their steal() dependency action)
 *
 * All our sub containers are called to return their javascripts as well.
 *
 * @param {String} scriptPath
 */
Interface.prototype.loadJavascripts = function( scriptPath ) 
{

    // set default path to interface directory if not already set:
    if (this.pathScripts == '') {
        this.pathScripts = this.pathInterface + '/scripts';
    }
    
    var localFiles =  fs.readdirSync(this.pathScripts);
    for (var iLF in localFiles) {
    
        // ignore files that begin with '.'
        if (localFiles[iLF].indexOf(".") != 0) {
        
            var filePath = this.pathScripts + '/' + localFiles[iLF];
            var pathStat = fs.statSync(filePath);
            if (pathStat.isFile()) {

                this.myListJS.push(relativePathFromRoot(filePath));
            
            }
        
         } 
        
    }
    
    //// now add in any javascripts from any dependent widgets:
    // for each widget in our dependency list
    for (var wi =0; wi < this.listWidgets.length; wi++) {
    
        var widgetKey = this.listWidgets[wi];
        
        // ListWidgets is a global defined by root app.js
        if (typeof ListWidgets[widgetKey] != 'undefined') {
        
            var widgetListJS = ListWidgets[widgetKey].listJS;
            
            // for each js listed in widget's list
            for (var ci =0; ci < widgetListJS.length; ci++) {
            
                // add to my currListCSS
                this.myListJS.push( widgetListJS[ci] );
                
            } // next css
        }
    } // next widget
    
    
    
    for(var i in this.containers) {
    
        var curList = this.containers[i].getJavascripts(list);
        for (var iCL in curList) {
            this.myListJS.push(curList[iCL]);
        }
        
    }
    
    this.myListJSLoaded = true;
}





//------------------------------------------------------------------------
/**
 * @function loadLabels
 * Pull the data from the DB for the labels associated with this interface.
 */
Interface.prototype.loadLabels = function() 
{
    AD.Lang.loadLabelsToArrayByPath( this.listLabels, this.pathLabels );
    
    this.listLabelsLoaded = true;
}





/**
 * @functions loadServices
 * Scans the defined `pathSevices` directory to see if there are any services
 * for this interface to load.
 *
 * Services are unique actions that an interface can generate.
 *
 * @param {Function} onError
 * @return {Deferred}
 *    A jQuery Deferred that will be resolved after all services have been
 *    loaded.
 */
Interface.prototype.loadServices = function( onError ) 
{
    // set default path to interface directory if not already set:
    if (this.pathServices == '') {
        this.pathServices = this.pathInterface + '/services';
    }

    var self = this;
    var dfd = $.Deferred();
    
    fs.readdir(this.pathServices, function (err, files) {

        if (err) { 
        
            if (typeof onError != 'undefined') {
                onError(err); 
            } else {            
                error(' ');
                error('**** path['+relativePathFromRoot(self.pathServices)+']');
                error('**** error['+err.message+']');
            }
            
        } else {

            log(' ');
            log('      ... Loading Services ['+relativePathFromRoot(self.pathServices)+']');
            for (var fi in files) {
                
                
                // ignore files that begin with '.'
                if (files[fi].indexOf(".") != 0) {
                
                    var servicePath = self.pathServices + '/' + files[fi];
                    
                    var pathStat = fs.statSync(servicePath);
                    if (pathStat.isFile()) {
                        
                        if (path.existsSync(servicePath)) {
                        
                            log('         - services/'+files[fi]);
                            
                            var service = self.module.require(servicePath);
                            service.module = self.module;
                            
                            // Services can have a setup() function exported. 
                            // Pass the `Interface.app` object into it so they
                            // can declare their routes that way if desired.
                            if (service.setup) {
                                service.setup(self.app);
                            }
                            
                            // Or maybe the service exports a `listRoutes` 
                            // object.
                            if (service.listRoutes) {
                                // Merge the service listRoutes into this 
                                // interface.
                                for (var verb in service.listRoutes) {
                                    if (!self.listRoutes[verb]) {
                                        self.listRoutes[verb] = {};
                                    }
                                    for (var routePath in service.listRoutes[verb]) {
                                        self.listRoutes[verb][routePath] = 
                                            service.listRoutes[verb][routePath];
                                    }
                                }
                            }
                            
                            self.services[files[fi]] = service;
                        
                        } // end if exists
                    
                    } // end if file
                        
                } // end if not '.' 
            
            } // next file


        }
        
        // finished the async operation
        dfd.resolve({});
        
    });

    return dfd;
}



Interface.prototype.createRoutes = function() {
	
    // define our Interface css file return
    var _self = this;
    var localFile = function(req, res, next) {

        log(req,'   - /' + _self.nameInterface + '/css/ being processed.');
        var parts = req.url.split('/'+_self.nameInterface+'/');
        var urlParts = parts[parts.length-1].split('?');
        var path = urlParts[0]; // without any additional params

        res.sendfile( _self.pathInterface+'/'+path);
    }

    var myPath = relativePathFromRoot(this.pathInterface).replace("modules","");
    this.app.get( myPath + '/css/*', localFile);	
	
}


/**
 * @function setup
 * Called from app_module.js loadInterfaces().
 * @param {Function} callback
 *     Optional callback function to be executed just before resolving the
 *     deferred.
 * @return {Deferred} 
 *     A jQuery Deferred object that will resolve when the interface and all
 *     of its services + containers have been initialized.
 */
Interface.prototype.setup = function( callback ) 
{
    var dfd = $.Deferred();
    
    //// Scan any sub containers to gather their routes
    var dfdContainers = this.loadContainers();

    //// Scan for any services and load them
    var dfdServices = this.loadServices();
    
    // Scan for any .css files registered for this interface
    this.loadInterfaceCSS();
    
    // Create our routes : interface/css
    this.createRoutes();
    
      
    $.when(dfdContainers, dfdServices).then(function() {
        callback && callback();
        dfd.resolve();
    });
    
    return dfd;
}




/**
 * @function loadFilePaths
 * 
 * Helper function used by loadInterfaceCSS, etc.
 * 
 * @param {String} dirPath
 * @param {String} varKey
 *    The `Module` property variable to store the results in.
 * @param {Function} onError
      Callback function to be called when an error occurs.
 * @param {String} fromPath
 *    (optional) Base path to use. Default is the appDev root.
 * @param {String} pathPrefix
 *    (optional)
 */
Interface.prototype.loadFilePaths = function (dirPath, varKey, onError, fromPath, pathPrefix) 
{
    var self = this;
    
    fromPath = fromPath || __appdevPath;
    pathPrefix = pathPrefix || '';
    
    fs.readdir( dirPath, function (err, files) {

        if (err) { 
            
            if (typeof onError != 'undefined') {
            
                onError(err);
                
            } else {
                error(' ');
                error('**** path['+relativePathFromRoot(dirPath)+']');
                error('**** error['+err.message+']');
            }
            
        } else {

            for (var fi in files) {
            
                // ignore files that begin with '.'
                if (files[fi].indexOf(".") != 0) {
                
                    var scriptPath = dirPath + '/' +files[fi];
                                
                    if (path.existsSync(scriptPath)) {
                                         
                        // if name is a file then (must be a script)
                        var pathStat = fs.statSync(scriptPath);
                        if (pathStat.isFile()) {
                        
                            self[varKey].push( pathPrefix+relativePath(fromPath, scriptPath) );
                        
                        } 
                    }
                
                } // end if ! '.xxx' file
                
            } // next file
            
        }

    });
}



/**
 * @function loadInterfaceCSS
 *
 * @param {Function} onError
 */
Interface.prototype.loadInterfaceCSS = function( onError ) 
{
    if (this.pathCSS == '') {
        this.pathCSS = this.pathInterface + '/css';
    }

	var relPath = relativePathFromRoot(this.pathInterface).replace('modules', '');

	this.loadFilePaths(this.pathCSS, 'myListLocalCSS', onError, this.pathInterface, relPath);
}
