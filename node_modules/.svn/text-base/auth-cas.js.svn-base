/**
 * @class authCAS
 * @parent Authentication
 *
 * This is the appDev object for handling CAS authentication. 
 *
 * Uses the cas module:
 *
 * * <https://github.com/joshchan/node-cas>
 * * `git clone git@github.com:joshchan/node-cas.git node_modules/cas`
 *
 * Which should eventually make it back into npm:
 *
 * * `npm install cas`
 *
 * An optional submodule for mapping CAS the login ID into a GUID can be 
 * specified during installation (`AD.Defaults.authCAS.submodule`). This 
 * should be a .js file placed inside the `node_modules` directory.
 */

var authCAS = AD.Defaults.authCAS;

// A submodule for mapping CAS the login ID into a GUID can be specified.
var casMapGUID = null;
if (authCAS.submodule) {
    /**
     * @function submodule
     *
     * This function should be the sole thing exported by the CAS
     * authentication submodule.
     *
     * Maps a CAS login into a GUID value. Async.
     *
     * @param {string} username
     *    The CAS login ID
     * @param {object} attributes
     *    A list of key:[value] attribute pairs, if any
     * @param {function} callback
     *    On completion this will be called with the GUID as parameter.
     *    `callback(err, guid)`
     */
    casMapGUID = require(authCAS.submodule);
}

var CAS = require('cas');
if (authCAS.path[0] != '/') {
    // add a slash in front of the CAS base path if needed
    authCAS.path = '/' + authCAS.path;
}
var cas = new CAS({
    base_url: 'https://'+authCAS.host+':'+authCAS.port+authCAS.path,
    version: 2.0,
    
    //// If using an external proxy server
    //external_pgt_url: 'https://test.dodomail.net:14003/',
    //external_proxy_url: 'https://test.dodomail.net:14002/'
    
    //// If using the built-in proxy server
    //proxy_server: true,
    //proxy_server_port: 14002,
    //proxy_callback_host: 'test.dodomail.net',
    //proxy_callback_port: 14003,
    //proxy_server_key: fs.readFileSync('/etc/pki/tls/private/test.dodomail.net.key'),
    //proxy_server_cert: fs.readFileSync('/etc/pki/tls/certs/test.dodomail.net.crt')
});

var authLabels;

/**
 * Pass in the labels.
 */
exports.setLabels = function(labels)
{
    authLabels = labels;
}


/**
 * @function getExemptedRoutes
 *
 * A list of routes that do not require authentication under this auth handler.
 *
 * @return {Array}
 */
exports.getExemptedRoutes = function() 
{
    return [
        // what's the logout URL?
    ];
}


// This will keep track of the CAS tickets and Express sessionID values.
var ticketSessionStore = {};
// Do garbage collection once every hour
setInterval(function() {
    var now = process.uptime();
    for (var ticket in ticketSessionStore) {
        var timestamp = ticketSessionStore[ticket]['timestamp'];
        // Delete entries older than 5 hours
        if (now - timestamp > 60 * 60 * 5) {
            delete ticketSessionStore[ticket];
        }
    }
}, 1000 * 60);



/**
 * @function preAuthentication
 *
 * Check if the CAS server is requesting us to logout a user.
 * 
 * @param {Object} req
 * @param {Object} res
 * @param {Function} next
 */
exports.preAuthentication = function(req, res, next)
{
    cas.handleSingleSignout(req, res, next, function(ticket) {
        destroySessionByTicket(ticket);
        res.end('OK');
        return;
    });
}


/**
 * Internal function used by both `authenticatePage()` and `autheticateService()`.
 * 
 * @param {Object} req
 * @param {Object} res
 * @param {Object} extended Extended user data returned by the CAS module.
 * @param {Function} errCallback
 * @param {Function} next
 */
var finishAuthentication = function(req, res, extended, errCallback, next)
{
    var username = extended['username'];
    var ticket = extended['ticket'];
    
    // Track the ticket and the session ID, so we can delete the session later
    // based on the ticket.
    ticketSessionStore[ticket] = { 
        'timestamp': process.uptime(),
        'sessionID': req.sessionID 
    };
    
    // Store the PGTIOU in the session if we got one
    if (extended['PGTIOU']) {
        req.session['CAS-PGTIOU'] = extended['PGTIOU'];
    } else {
        req.session['CAS-PGTIOU'] = undefined;
    }

    // Map the CAS username into a GUID using a submodule
    if (casMapGUID) {
        var attributes = extended['attributes'];
        casMapGUID(username, attributes, function(err, guid) {
            if (err) {
                errCallback(err);
                return;
            }
            else {
                createSession(req, res, next, username, guid);
                return;
            }
        });
    }
    // No submodule. Use the username directly as GUID.
    else {
        var guid = username;
        createSession(req, res, next, username, guid);
        return;
    }

}


/**
 * @function authenticatePage
 *
 * CAS authentication for a web page.
 *
 * @param object req
 * @param object res
 * @param function next
 */
exports.authenticatePage = function(req, res, next) 
{
    // Force CAS authentication and fetch the username
    cas.authenticate(req, res, function(err, status, username, extended) {
        if (err) {
            // There was a CAS error. There is no way to recover from this.
            res.writeHead(401, {'Content-Type': 'text/html'});
            res.write("<dt>CAS login failed</dt>");
            res.write('<dd>' + err.message + '</dd>');
            res.end();
            return;
        }
        else {
            finishAuthentication(req, res, extended, 
                // GUID mapping error
                function(err) {
                    res.writeHead(401, {'Content-Type': 'text/html'});
                    res.write('<dt>Sorry, your login could not be completed.</dt>');
                    res.write('<dd>' + err.message + '</dd>');
                    res.end();
                    return;
                },
                // Success
                next
            );
        }
    });
}


/**
 * @function authenticateService
 *
 * CAS authentication for a web service.
 *
 * @param object req
 * @param object res
 * @param function next
 *      The callback to execute if authentication passes.
 */
exports.authenticateService = function(req, res, next) 
{
    // Looks like we have a proxy ticket. Go ahead and authenticate that.
    if (req.query['ticket']) {
        cas.authenticate(req, res, function(err, status, username, extended) {
            if (err) {
                // unexpected CAS error
                AD.Comm.Service.sendError(req, res, {
                    errorID: 55,
                    errorMSG: err.message
                });
                return;
            }
            finishAuthentication(req, res, extended,
                // GUID mapping error
                function(err) {
                    AD.Comm.Service.sendError(req, res, {
                        errorID: 0,
                        errorMSG: err.message
                    });
                },
                // Success
                next
            );
        });
        return;
    }
    
    // No ticket, so that means the requestor is not authenticated, and is 
    // not a CAS proxy.
    else {
        AD.Comm.Service.sendError(req, res, {
            errorID: 55, 
            errorMSG: authLabels['[site.autherrors.Reauthenticate]'][req.aRAD.defaults['siteDefaultLanguage']]
        });
    }
}


/**
 * @function logoutPage
 *
 * Log the user out and return to the default page.
 */
exports.logoutPage = function(req, res, returnUrl) 
{
    if (!returnUrl) {
        returnUrl = AD.Defaults.siteURL;
    }
    cas.logout(req, res, returnUrl, true);
}


/**
 * @function login
 *
 * A service that accepts authentication credentials and sends a response.
 * This has no purpose under CAS.
 * 
 * @param {Object} req
 * @param {Object} res
 * @param {Function} next
 */
exports.login = function(req, res, next) {}


/**
 * Logs a user in using their viewer_globalUserID.
 * This will automatically create a new viewer entry if one does not exist.
 *
 * @param object req
 * @param object res
 * @param function next
 * @param string username
 * @param string guid
 */
var createSession = function(req, res, next, username, guid) 
{
    AD.Viewer.viewerFromGUID(guid, function(err, currentViewer) {
        
        var success = function() {
            if (!currentViewer['viewer_isActive']) {
                // viewer account has been disabled by an admin
                res.send("Your global CAS login is good, but your account on this site has been disabled. Sorry.");
                return;
            }
            else {
                // store viewer in session
                currentViewer.isAuthenticated = true;
                req.session.viewer = currentViewer;
                if (next) {
                    return next();
                }
            }
        };
        
        // No existing viewer with that GUID is found. 
        if (err || !currentViewer.viewer_id) {
            // So create the viewer now, and execute the callback.
            currentViewer.guid = guid;
            currentViewer.userID = username;
            currentViewer.viewer_isActive = 1;
            AD.Viewer.createViewer({
                'viewer_globalUserID': guid,
                'viewer_userID': username,
                'viewer_passWord': '--CAS--',
                'viewer_isActive': 1,
                'viewer_lastLogin': "now"
            }, success);
        } 

        // Existing viewer found. Execute the callback.
        else {
            // Update the last login date, and also the userID if needed
            AD.Viewer.updateViewer({
                'viewer_id': currentViewer.viewer_id,
                'viewer_userID': username,
                'viewer_lastLogin': "now"
            }, success);
        }
    });
}


/**
 * Find a logged in user by the ST (CAS service ticket) that they used to 
 * log in with, and delete their session.
 *
 * @param string ticket
 */
var destroySessionByTicket = function(ticket)
{
    if (ticketSessionStore[ticket]) {
        var sessionID = ticketSessionStore[ticket]['sessionID'];
        process.nextTick(function() {
            AD.SessionStore.destroy(sessionID);
        });
    }
}


/**
 * An array of additional routes needed for CAS authentication
 */
exports.routes = {
    
    /**
     * @function routes."page/cas/frame-auth"
     *
     * @codestart
     * /page/cas/frame-auth
     * @codeend
     *
     * A CAS-authenticated blank HTML page that will close itself 
     * with Javascript. 
     *
     * It is meant to be opened inside an IFRAME when the user needs to
     * reauthenticate after a session has timed out. The frame will redirect
     * to the CAS login page, and return with the new login ticket. Once
     * validation passes the session will be updated and the frame should
     * close.
     *
     * see `data/scripts/appDev/appDev.js`
     */

    /*
     */

    '/page/cas/frame-auth': function(req, res, next) {
        res.send(" \
<!DOCTYPE html> \
<html> \
    <head> \
        <script type='text/javascript'> \
            if (top.AppDev) { \
                top.AppDev.winLogin.done(); \
            } else { \
                window.close(); \
            } \
        </script> \
    </head> \
    <body> \
        <div style='width:5em; margin:8em auto;'>Logging in...</div> \
    </body> \
</html> \
        ");
    }

};

